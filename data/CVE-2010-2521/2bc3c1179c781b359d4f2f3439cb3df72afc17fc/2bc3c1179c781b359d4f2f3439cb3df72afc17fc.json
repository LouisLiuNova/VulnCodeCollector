{
    "owner": "torvalds",
    "repo": "linux",
    "commit_sha": "2bc3c1179c781b359d4f2f3439cb3df72afc17fc",
    "commit_massage": "nfsd4: bug in read_buf\n\nWhen read_buf is called to move over to the next page in the pagelist\nof an NFSv4 request, it sets argp->end to essentially a random\nnumber, certainly not an address within the page which argp->p now\npoints to.  So subsequent calls to READ_BUF will think there is much\nmore than a page of spare space (the cast to u32 ensures an unsigned\ncomparison) so we can expect to fall off the end of the second\npage.\n\nWe never encountered thsi in testing because typically the only\noperations which use more than two pages are write-like operations,\nwhich have their own decoding logic.  Something like a getattr after a\nwrite may cross a page boundary, but it would be very unusual for it to\ncross another boundary after that.\n\nCc: stable@kernel.org\nSigned-off-by: J. Bruce Fields <bfields@citi.umich.edu>",
    "raw_ref": "https://api.github.com/repos/torvalds/linux/commits/2bc3c1179c781b359d4f2f3439cb3df72afc17fc",
    "html_ref": "https://github.com/torvalds/linux/commit/2bc3c1179c781b359d4f2f3439cb3df72afc17fc",
    "author": "neilbrown",
    "changes_stats": {
        "total": 8,
        "additions": 4,
        "deletions": 4
    },
    "files": [
        {
            "sha": "34ccf815ea8aa48f854a8ad6f9d15e64c2c59e51",
            "filename": "fs/nfsd/nfs4xdr.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/torvalds/linux/blob/2bc3c1179c781b359d4f2f3439cb3df72afc17fc/fs%2Fnfsd%2Fnfs4xdr.c",
            "raw_url": "https://github.com/torvalds/linux/raw/2bc3c1179c781b359d4f2f3439cb3df72afc17fc/fs%2Fnfsd%2Fnfs4xdr.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/fs%2Fnfsd%2Fnfs4xdr.c?ref=2bc3c1179c781b359d4f2f3439cb3df72afc17fc",
            "patch": "@@ -161,10 +161,10 @@ static __be32 *read_buf(struct nfsd4_compoundargs *argp, u32 nbytes)\n \targp->p = page_address(argp->pagelist[0]);\n \targp->pagelist++;\n \tif (argp->pagelen < PAGE_SIZE) {\n-\t\targp->end = p + (argp->pagelen>>2);\n+\t\targp->end = argp->p + (argp->pagelen>>2);\n \t\targp->pagelen = 0;\n \t} else {\n-\t\targp->end = p + (PAGE_SIZE>>2);\n+\t\targp->end = argp->p + (PAGE_SIZE>>2);\n \t\targp->pagelen -= PAGE_SIZE;\n \t}\n \tmemcpy(((char*)p)+avail, argp->p, (nbytes - avail));\n@@ -1426,10 +1426,10 @@ nfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n \t\t\targp->p = page_address(argp->pagelist[0]);\n \t\t\targp->pagelist++;\n \t\t\tif (argp->pagelen < PAGE_SIZE) {\n-\t\t\t\targp->end = p + (argp->pagelen>>2);\n+\t\t\t\targp->end = argp->p + (argp->pagelen>>2);\n \t\t\t\targp->pagelen = 0;\n \t\t\t} else {\n-\t\t\t\targp->end = p + (PAGE_SIZE>>2);\n+\t\t\t\targp->end = argp->p + (PAGE_SIZE>>2);\n \t\t\t\targp->pagelen -= PAGE_SIZE;\n \t\t\t}\n \t\t}"
        }
    ],
    "parent_commit_sha": "0d0fb0f9c5fddef4a10242fe3337f00f528a3099"
}