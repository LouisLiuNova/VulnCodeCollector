{
    "owner": "bonzini",
    "repo": "qemu",
    "commit_sha": "7285477ab11831b1cf56e45878a89170dd06d9b9",
    "commit_massage": "scsi-disk: lazily allocate bounce buffer\n\nIt will not be needed for reads and writes if the HBA provides a sglist.\nIn addition, this lets scsi-disk refuse commands with an excessive\nallocation length, as well as limit memory on usual well-behaved guests.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>",
    "raw_ref": "https://api.github.com/repos/bonzini/qemu/commits/7285477ab11831b1cf56e45878a89170dd06d9b9",
    "html_ref": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
    "author": "bonzini",
    "changes_stats": {
        "total": 44,
        "additions": 33,
        "deletions": 11
    },
    "files": [
        {
            "sha": "48abe49496abfcfae4c463f63e8173a5146c6e29",
            "filename": "hw/scsi-disk.c",
            "status": "modified",
            "additions": 33,
            "deletions": 11,
            "changes": 44,
            "blob_url": "https://github.com/bonzini/qemu/blob/7285477ab11831b1cf56e45878a89170dd06d9b9/hw%2Fscsi-disk.c",
            "raw_url": "https://github.com/bonzini/qemu/raw/7285477ab11831b1cf56e45878a89170dd06d9b9/hw%2Fscsi-disk.c",
            "contents_url": "https://api.github.com/repos/bonzini/qemu/contents/hw%2Fscsi-disk.c?ref=7285477ab11831b1cf56e45878a89170dd06d9b9",
            "patch": "@@ -55,6 +55,7 @@ typedef struct SCSIDiskReq {\n     /* Both sector and sector_count are in terms of qemu 512 byte blocks.  */\n     uint64_t sector;\n     uint32_t sector_count;\n+    uint32_t buflen;\n     struct iovec iov;\n     QEMUIOVector qiov;\n     uint32_t status;\n@@ -78,13 +79,15 @@ struct SCSIDiskState\n };\n \n static int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type);\n-static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf);\n+static int scsi_disk_emulate_command(SCSIDiskReq *r);\n \n static void scsi_free_request(SCSIRequest *req)\n {\n     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n \n-    qemu_vfree(r->iov.iov_base);\n+    if (r->iov.iov_base) {\n+        qemu_vfree(r->iov.iov_base);\n+    }\n }\n \n /* Helper function for command completion with sense.  */\n@@ -110,7 +113,13 @@ static void scsi_cancel_io(SCSIRequest *req)\n \n static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n {\n-    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n+    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n+\n+    if (!r->iov.iov_base) {\n+        r->buflen = SCSI_DMA_BUF_SIZE;\n+        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n+    }\n+    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n     qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n     return r->qiov.size / 512;\n }\n@@ -323,7 +332,7 @@ static void scsi_dma_restart_bh(void *opaque)\n                 scsi_write_data(&r->req);\n                 break;\n             case SCSI_REQ_STATUS_RETRY_FLUSH:\n-                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n+                ret = scsi_disk_emulate_command(r);\n                 if (ret == 0) {\n                     scsi_req_complete(&r->req, GOOD);\n                 }\n@@ -838,13 +847,31 @@ static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n     return 0;\n }\n \n-static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n+static int scsi_disk_emulate_command(SCSIDiskReq *r)\n {\n     SCSIRequest *req = &r->req;\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n     uint64_t nb_sectors;\n+    uint8_t *outbuf;\n     int buflen = 0;\n \n+    if (!r->iov.iov_base) {\n+        /*\n+         * FIXME: we shouldn't return anything bigger than 4k, but the code\n+         * requires the buffer to be as big as req->cmd.xfer in several\n+         * places.  So, do not allow CDBs with a very large ALLOCATION\n+         * LENGTH.  The real fix would be to modify scsi_read_data and\n+         * dma_buf_read, so that they return data beyond the buflen\n+         * as all zeros.\n+         */\n+        if (req->cmd.xfer > 65536) {\n+            goto illegal_request;\n+        }\n+        r->buflen = MAX(4096, req->cmd.xfer);\n+        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n+    }\n+\n+    outbuf = r->iov.iov_base;\n     switch (req->cmd.buf[0]) {\n     case TEST_UNIT_READY:\n         if (s->tray_open || !bdrv_is_inserted(s->bs))\n@@ -995,11 +1022,9 @@ static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n     int32_t len;\n     uint8_t command;\n-    uint8_t *outbuf;\n     int rc;\n \n     command = buf[0];\n-    outbuf = (uint8_t *)r->iov.iov_base;\n     DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n \n #ifdef DEBUG_SCSI\n@@ -1028,7 +1053,7 @@ static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n     case GET_CONFIGURATION:\n     case SERVICE_ACTION_IN_16:\n     case VERIFY_10:\n-        rc = scsi_disk_emulate_command(r, outbuf);\n+        rc = scsi_disk_emulate_command(r);\n         if (rc < 0) {\n             return 0;\n         }\n@@ -1279,11 +1304,8 @@ static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n {\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n     SCSIRequest *req;\n-    SCSIDiskReq *r;\n \n     req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n-    r = DO_UPCAST(SCSIDiskReq, req, req);\n-    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n     return req;\n }\n "
        }
    ],
    "parent_commit_sha": "103b40f51e4012b3b0ad20f615562a1806d7f49a"
}