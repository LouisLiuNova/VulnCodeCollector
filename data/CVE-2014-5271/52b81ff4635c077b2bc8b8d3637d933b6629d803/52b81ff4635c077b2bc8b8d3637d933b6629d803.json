{
    "owner": "FFmpeg",
    "repo": "FFmpeg",
    "commit_sha": "52b81ff4635c077b2bc8b8d3637d933b6629d803",
    "commit_massage": "proresenc_kostya: report buffer overflow\n\nIf the allocated size, despite best efforts, is too small, exit\nwith the appropriate error.\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "raw_ref": "https://api.github.com/repos/FFmpeg/FFmpeg/commits/52b81ff4635c077b2bc8b8d3637d933b6629d803",
    "html_ref": "https://github.com/FFmpeg/FFmpeg/commit/52b81ff4635c077b2bc8b8d3637d933b6629d803",
    "author": "cgisquet",
    "changes_stats": {
        "total": 13,
        "additions": 10,
        "deletions": 3
    },
    "files": [
        {
            "sha": "a70ae3cbc71fde97338cbe1d92ac11d8ed68af33",
            "filename": "libavcodec/proresenc_kostya.c",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/FFmpeg/FFmpeg/blob/52b81ff4635c077b2bc8b8d3637d933b6629d803/libavcodec%2Fproresenc_kostya.c",
            "raw_url": "https://github.com/FFmpeg/FFmpeg/raw/52b81ff4635c077b2bc8b8d3637d933b6629d803/libavcodec%2Fproresenc_kostya.c",
            "contents_url": "https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec%2Fproresenc_kostya.c?ref=52b81ff4635c077b2bc8b8d3637d933b6629d803",
            "patch": "@@ -570,6 +570,11 @@ static int encode_slice(AVCodecContext *avctx, const AVFrame *pic,\n                                           quant);\n         }\n         total_size += sizes[i];\n+        if (put_bits_left(pb) < 0) {\n+            av_log(avctx, AV_LOG_ERROR, \"Serious underevaluation of\"\n+                   \"required buffer size\");\n+            return AVERROR_BUFFER_TOO_SMALL;\n+        }\n     }\n     return total_size;\n }\n@@ -940,9 +945,9 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n     avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n     avctx->coded_frame->key_frame = 1;\n \n-    pkt_size = ctx->frame_size_upper_bound + FF_MIN_BUFFER_SIZE;\n+    pkt_size = ctx->frame_size_upper_bound;\n \n-    if ((ret = ff_alloc_packet2(avctx, pkt, pkt_size)) < 0)\n+    if ((ret = ff_alloc_packet2(avctx, pkt, pkt_size + FF_MIN_BUFFER_SIZE)) < 0)\n         return ret;\n \n     orig_buf = pkt->data;\n@@ -1019,7 +1024,9 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n                 slice_hdr = buf;\n                 buf += slice_hdr_size - 1;\n                 init_put_bits(&pb, buf, (pkt_size - (buf - orig_buf)) * 8);\n-                encode_slice(avctx, pic, &pb, sizes, x, y, q, mbs_per_slice);\n+                ret = encode_slice(avctx, pic, &pb, sizes, x, y, q, mbs_per_slice);\n+                if (ret < 0)\n+                    return ret;\n \n                 bytestream_put_byte(&slice_hdr, q);\n                 slice_size = slice_hdr_size + sizes[ctx->num_planes - 1];"
        }
    ],
    "parent_commit_sha": "bf10f09bccdcfdb41b9f5bbae01d55961bfd0693"
}