{"owner": "vadz", "repo": "libtiff", "commit_sha": "3ca657a8793dd011bf869695d72ad31c779c3cc1", "commit_massage": "* libtiff/tif_predict.h, libtiff/tif_predict.c:\nReplace assertions by runtime checks to avoid assertions in debug mode,\nor buffer overflows in release mode. Can happen when dealing with\nunusual tile size like YCbCr with subsampling. Reported as MSVR 35105\nby Axel Souchet\t& Vishal Chauhan from the MSRC Vulnerabilities & Mitigations\nteam.", "raw_ref": "https://api.github.com/repos/vadz/libtiff/commits/3ca657a8793dd011bf869695d72ad31c779c3cc1", "html_ref": "https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1", "author": "erouault", "changes_stats": {"total": 168, "additions": 121, "deletions": 47}, "files": [{"sha": "0379c3b7c3354f758382b942fbc6e104a823b424", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/vadz/libtiff/blob/3ca657a8793dd011bf869695d72ad31c779c3cc1/ChangeLog", "raw_url": "https://github.com/vadz/libtiff/raw/3ca657a8793dd011bf869695d72ad31c779c3cc1/ChangeLog", "contents_url": "https://api.github.com/repos/vadz/libtiff/contents/ChangeLog?ref=3ca657a8793dd011bf869695d72ad31c779c3cc1", "patch": "@@ -1,3 +1,12 @@\n+2016-10-31 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* libtiff/tif_predict.h, libtiff/tif_predict.c:\n+\tReplace assertions by runtime checks to avoid assertions in debug mode,\n+\tor buffer overflows in release mode. Can happen when dealing with\n+\tunusual tile size like YCbCr with subsampling. Reported as MSVR 35105\n+\tby Axel Souchet\t& Vishal Chauhan from the MSRC Vulnerabilities & Mitigations\n+\tteam.\n+\n 2016-10-26 Even Rouault <even.rouault at spatialys.com>\n \n \t* tools/fax2tiff.c: fix segfault when specifying -r without"}, {"sha": "b829259aeae92eb83bd6691eeaf47630017d0617", "filename": "libtiff/tif_predict.c", "status": "modified", "additions": 108, "deletions": 45, "changes": 153, "blob_url": "https://github.com/vadz/libtiff/blob/3ca657a8793dd011bf869695d72ad31c779c3cc1/libtiff%2Ftif_predict.c", "raw_url": "https://github.com/vadz/libtiff/raw/3ca657a8793dd011bf869695d72ad31c779c3cc1/libtiff%2Ftif_predict.c", "contents_url": "https://api.github.com/repos/vadz/libtiff/contents/libtiff%2Ftif_predict.c?ref=3ca657a8793dd011bf869695d72ad31c779c3cc1", "patch": "@@ -34,18 +34,18 @@\n \n #define\tPredictorState(tif)\t((TIFFPredictorState*) (tif)->tif_data)\n \n-static void horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc);\n-static void fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static int fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc);\n static int PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s);\n static int PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s);\n static int PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s);\n@@ -273,13 +273,19 @@ PredictorSetupEncode(TIFF* tif)\n /* - when storing into the byte stream, we explicitly mask with 0xff so */\n /*   as to make icc -check=conversions happy (not necessary by the standard) */\n \n-static void\n+static int\n horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \ttmsize_t stride = PredictorState(tif)->stride;\n \n \tunsigned char* cp = (unsigned char*) cp0;\n-\tassert((cc%stride)==0);\n+    if((cc%stride)!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",\n+                     \"%s\", \"(cc%stride)!=0\");\n+        return 0;\n+    }\n+\n \tif (cc > stride) {\n \t\t/*\n \t\t * Pipeline the most common cases.\n@@ -321,26 +327,32 @@ horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t\t\t} while (cc>0);\n \t\t}\n \t}\n+\treturn 1;\n }\n \n-static void\n+static int\n swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tuint16* wp = (uint16*) cp0;\n \ttmsize_t wc = cc / 2;\n \n         TIFFSwabArrayOfShort(wp, wc);\n-        horAcc16(tif, cp0, cc);\n+        return horAcc16(tif, cp0, cc);\n }\n \n-static void\n+static int\n horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \ttmsize_t stride = PredictorState(tif)->stride;\n \tuint16* wp = (uint16*) cp0;\n \ttmsize_t wc = cc / 2;\n \n-\tassert((cc%(2*stride))==0);\n+    if((cc%(2*stride))!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"horAcc16\",\n+                     \"%s\", \"cc%(2*stride))!=0\");\n+        return 0;\n+    }\n \n \tif (wc > stride) {\n \t\twc -= stride;\n@@ -349,26 +361,32 @@ horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t\t\twc -= stride;\n \t\t} while (wc > 0);\n \t}\n+\treturn 1;\n }\n \n-static void\n+static int\n swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tuint32* wp = (uint32*) cp0;\n \ttmsize_t wc = cc / 4;\n \n         TIFFSwabArrayOfLong(wp, wc);\n-\thorAcc32(tif, cp0, cc);\n+\treturn horAcc32(tif, cp0, cc);\n }\n \n-static void\n+static int\n horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \ttmsize_t stride = PredictorState(tif)->stride;\n \tuint32* wp = (uint32*) cp0;\n \ttmsize_t wc = cc / 4;\n \n-\tassert((cc%(4*stride))==0);\n+    if((cc%(4*stride))!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"horAcc32\",\n+                     \"%s\", \"cc%(4*stride))!=0\");\n+        return 0;\n+    }\n \n \tif (wc > stride) {\n \t\twc -= stride;\n@@ -377,12 +395,13 @@ horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t\t\twc -= stride;\n \t\t} while (wc > 0);\n \t}\n+\treturn 1;\n }\n \n /*\n  * Floating point predictor accumulation routine.\n  */\n-static void\n+static int\n fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \ttmsize_t stride = PredictorState(tif)->stride;\n@@ -392,10 +411,15 @@ fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n \tuint8 *cp = (uint8 *) cp0;\n \tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n \n-\tassert((cc%(bps*stride))==0);\n+    if(cc%(bps*stride)!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n+                     \"%s\", \"cc%(bps*stride))!=0\");\n+        return 0;\n+    }\n \n \tif (!tmp)\n-\t\treturn;\n+\t\treturn 0;\n \n \twhile (count > stride) {\n \t\tREPEAT4(stride, cp[stride] =\n@@ -417,6 +441,7 @@ fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t\t}\n \t}\n \t_TIFFfree(tmp);\n+    return 1;\n }\n \n /*\n@@ -432,8 +457,7 @@ PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n \tassert(sp->decodepfunc != NULL);  \n \n \tif ((*sp->decoderow)(tif, op0, occ0, s)) {\n-\t\t(*sp->decodepfunc)(tif, op0, occ0);\n-\t\treturn 1;\n+\t\treturn (*sp->decodepfunc)(tif, op0, occ0);\n \t} else\n \t\treturn 0;\n }\n@@ -456,10 +480,16 @@ PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n \tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n \t\ttmsize_t rowsize = sp->rowsize;\n \t\tassert(rowsize > 0);\n-\t\tassert((occ0%rowsize)==0);\n+\t\tif((occ0%rowsize) !=0)\n+        {\n+            TIFFErrorExt(tif->tif_clientdata, \"PredictorDecodeTile\",\n+                         \"%s\", \"occ0%rowsize != 0\");\n+            return 0;\n+        }\n \t\tassert(sp->decodepfunc != NULL);\n \t\twhile (occ0 > 0) {\n-\t\t\t(*sp->decodepfunc)(tif, op0, rowsize);\n+\t\t\tif( !(*sp->decodepfunc)(tif, op0, rowsize) )\n+                return 0;\n \t\t\tocc0 -= rowsize;\n \t\t\top0 += rowsize;\n \t\t}\n@@ -468,14 +498,19 @@ PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n \t\treturn 0;\n }\n \n-static void\n+static int\n horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tTIFFPredictorState* sp = PredictorState(tif);\n \ttmsize_t stride = sp->stride;\n \tunsigned char* cp = (unsigned char*) cp0;\n \n-\tassert((cc%stride)==0);\n+    if((cc%stride)!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",\n+                     \"%s\", \"(cc%stride)!=0\");\n+        return 0;\n+    }\n \n \tif (cc > stride) {\n \t\tcc -= stride;\n@@ -513,17 +548,23 @@ horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t\t\t} while ((cc -= stride) > 0);\n \t\t}\n \t}\n+\treturn 1;\n }\n \n-static void\n+static int\n horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tTIFFPredictorState* sp = PredictorState(tif);\n \ttmsize_t stride = sp->stride;\n \tuint16 *wp = (uint16*) cp0;\n \ttmsize_t wc = cc/2;\n \n-\tassert((cc%(2*stride))==0);\n+    if((cc%(2*stride))!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",\n+                     \"%s\", \"(cc%(2*stride))!=0\");\n+        return 0;\n+    }\n \n \tif (wc > stride) {\n \t\twc -= stride;\n@@ -533,28 +574,36 @@ horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t\t\twc -= stride;\n \t\t} while (wc > 0);\n \t}\n+\treturn 1;\n }\n \n-static void\n+static int\n swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n     uint16* wp = (uint16*) cp0;\n     tmsize_t wc = cc / 2;\n \n-    horDiff16(tif, cp0, cc);\n+    if( !horDiff16(tif, cp0, cc) )\n+        return 0;\n \n     TIFFSwabArrayOfShort(wp, wc);\n+    return 1;\n }\n \n-static void\n+static int\n horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tTIFFPredictorState* sp = PredictorState(tif);\n \ttmsize_t stride = sp->stride;\n \tuint32 *wp = (uint32*) cp0;\n \ttmsize_t wc = cc/4;\n \n-\tassert((cc%(4*stride))==0);\n+    if((cc%(4*stride))!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"horDiff32\",\n+                     \"%s\", \"(cc%(4*stride))!=0\");\n+        return 0;\n+    }\n \n \tif (wc > stride) {\n \t\twc -= stride;\n@@ -564,23 +613,26 @@ horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t\t\twc -= stride;\n \t\t} while (wc > 0);\n \t}\n+\treturn 1;\n }\n \n-static void\n+static int\n swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n     uint32* wp = (uint32*) cp0;\n     tmsize_t wc = cc / 4;\n \n-    horDiff32(tif, cp0, cc);\n+    if( !horDiff32(tif, cp0, cc) )\n+        return 0;\n \n     TIFFSwabArrayOfLong(wp, wc);\n+    return 1;\n }\n \n /*\n  * Floating point predictor differencing routine.\n  */\n-static void\n+static int\n fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \ttmsize_t stride = PredictorState(tif)->stride;\n@@ -590,10 +642,14 @@ fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n \tuint8 *cp = (uint8 *) cp0;\n \tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n \n-\tassert((cc%(bps*stride))==0);\n-\n+    if((cc%(bps*stride))!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n+                     \"%s\", \"(cc%(bps*stride))!=0\");\n+        return 0;\n+    }\n \tif (!tmp)\n-\t\treturn;\n+\t\treturn 0;\n \n \t_TIFFmemcpy(tmp, cp0, cc);\n \tfor (count = 0; count < wc; count++) {\n@@ -613,6 +669,7 @@ fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n \tcp += cc - stride - 1;\n \tfor (count = cc; count > stride; count -= stride)\n \t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n+    return 1;\n }\n \n static int\n@@ -625,7 +682,8 @@ PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n \tassert(sp->encoderow != NULL);\n \n \t/* XXX horizontal differencing alters user's data XXX */\n-\t(*sp->encodepfunc)(tif, bp, cc);\n+\tif( !(*sp->encodepfunc)(tif, bp, cc) )\n+        return 0;\n \treturn (*sp->encoderow)(tif, bp, cc, s);\n }\n \n@@ -660,7 +718,12 @@ PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n \n \trowsize = sp->rowsize;\n \tassert(rowsize > 0);\n-\tassert((cc0%rowsize)==0);\n+\tif((cc0%rowsize)!=0)\n+    {\n+        TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",\n+                     \"%s\", \"(cc0%rowsize)!=0\");\n+        return 0;\n+    }\n \twhile (cc > 0) {\n \t\t(*sp->encodepfunc)(tif, bp, rowsize);\n \t\tcc -= rowsize;"}, {"sha": "9e485a4b85e34eac7ffa12a1dbedbd39a7e96ffe", "filename": "libtiff/tif_predict.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/vadz/libtiff/blob/3ca657a8793dd011bf869695d72ad31c779c3cc1/libtiff%2Ftif_predict.h", "raw_url": "https://github.com/vadz/libtiff/raw/3ca657a8793dd011bf869695d72ad31c779c3cc1/libtiff%2Ftif_predict.h", "contents_url": "https://api.github.com/repos/vadz/libtiff/contents/libtiff%2Ftif_predict.h?ref=3ca657a8793dd011bf869695d72ad31c779c3cc1", "patch": "@@ -30,6 +30,8 @@\n  * ``Library-private'' Support for the Predictor Tag\n  */\n \n+typedef int (*TIFFEncodeDecodeMethod)(TIFF* tif, uint8* buf, tmsize_t size);\n+\n /*\n  * Codecs that want to support the Predictor tag must place\n  * this structure first in their private state block so that\n@@ -43,12 +45,12 @@ typedef struct {\n \tTIFFCodeMethod  encoderow;\t/* parent codec encode/decode row */\n \tTIFFCodeMethod  encodestrip;\t/* parent codec encode/decode strip */\n \tTIFFCodeMethod  encodetile;\t/* parent codec encode/decode tile */ \n-\tTIFFPostMethod  encodepfunc;\t/* horizontal differencer */\n+\tTIFFEncodeDecodeMethod  encodepfunc;\t/* horizontal differencer */\n \n \tTIFFCodeMethod  decoderow;\t/* parent codec encode/decode row */\n \tTIFFCodeMethod  decodestrip;\t/* parent codec encode/decode strip */\n \tTIFFCodeMethod  decodetile;\t/* parent codec encode/decode tile */ \n-\tTIFFPostMethod  decodepfunc;\t/* horizontal accumulator */\n+\tTIFFEncodeDecodeMethod  decodepfunc;\t/* horizontal accumulator */\n \n \tTIFFVGetMethod  vgetparent;\t/* super-class method */\n \tTIFFVSetMethod  vsetparent;\t/* super-class method */"}], "parent_commit_sha": "ed9e07c03017826bfbac1a9d6a9d261262e13126"}