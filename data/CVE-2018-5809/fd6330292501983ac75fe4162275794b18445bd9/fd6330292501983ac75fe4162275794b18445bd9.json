{"owner": "LibRaw", "repo": "LibRaw", "commit_sha": "fd6330292501983ac75fe4162275794b18445bd9", "commit_massage": "Secunia 81800#1: samsumg_load_raw\n\nSecunia 81800#2: find_green\n\nSecunia 81800#3: rollei_load_raw\n\nremove_trailing_spaces: isspace() does not works right with signed non-latin chars\n\nSecunia 81800#5/6: nikon_coolscan_load_raw\n\nSecunia 81800#4: rollei_load_raw", "raw_ref": "https://api.github.com/repos/LibRaw/LibRaw/commits/fd6330292501983ac75fe4162275794b18445bd9", "html_ref": "https://github.com/LibRaw/LibRaw/commit/fd6330292501983ac75fe4162275794b18445bd9", "author": "alextutubalin", "changes_stats": {"total": 314, "additions": 216, "deletions": 98}, "files": [{"sha": "e2b9c7d48811e5d51d9c467022179481a9fe5089", "filename": "dcraw/dcraw.c", "status": "modified", "additions": 108, "deletions": 49, "changes": 157, "blob_url": "https://github.com/LibRaw/LibRaw/blob/fd6330292501983ac75fe4162275794b18445bd9/dcraw%2Fdcraw.c", "raw_url": "https://github.com/LibRaw/LibRaw/raw/fd6330292501983ac75fe4162275794b18445bd9/dcraw%2Fdcraw.c", "contents_url": "https://api.github.com/repos/LibRaw/LibRaw/contents/dcraw%2Fdcraw.c?ref=fd6330292501983ac75fe4162275794b18445bd9", "patch": "@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  */\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n //@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 / 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  // definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) // less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           // Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; // broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; // too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; // also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; // not needed, b/c sizeof of make/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; // also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }"}, {"sha": "b430d3e5ed32ed0ba3046b1be3c47f6796b9608c", "filename": "internal/dcraw_common.cpp", "status": "modified", "additions": 107, "deletions": 49, "changes": 156, "blob_url": "https://github.com/LibRaw/LibRaw/blob/fd6330292501983ac75fe4162275794b18445bd9/internal%2Fdcraw_common.cpp", "raw_url": "https://github.com/LibRaw/LibRaw/raw/fd6330292501983ac75fe4162275794b18445bd9/internal%2Fdcraw_common.cpp", "contents_url": "https://api.github.com/repos/LibRaw/LibRaw/contents/internal%2Fdcraw_common.cpp?ref=fd6330292501983ac75fe4162275794b18445bd9", "patch": "@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 / 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  // definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) // less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           // Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; // broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; // too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; // also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; // not needed, b/c sizeof of make/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; // also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }"}, {"sha": "06e171ec0cb8b3628250d6feefee3199b60e7914", "filename": "internal/defines.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/LibRaw/LibRaw/blob/fd6330292501983ac75fe4162275794b18445bd9/internal%2Fdefines.h", "raw_url": "https://github.com/LibRaw/LibRaw/raw/fd6330292501983ac75fe4162275794b18445bd9/internal%2Fdefines.h", "contents_url": "https://api.github.com/repos/LibRaw/LibRaw/contents/internal%2Fdefines.h?ref=fd6330292501983ac75fe4162275794b18445bd9", "patch": "@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  */\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\"}], "parent_commit_sha": "5161244b5dde388ec8f99ec4d695cda4dafd07b6"}