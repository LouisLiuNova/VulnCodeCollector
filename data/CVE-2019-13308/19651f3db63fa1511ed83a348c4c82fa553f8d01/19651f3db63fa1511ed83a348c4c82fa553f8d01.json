{
    "owner": "ImageMagick",
    "repo": "ImageMagick6",
    "commit_sha": "19651f3db63fa1511ed83a348c4c82fa553f8d01",
    "commit_massage": "https://github.com/ImageMagick/ImageMagick/issues/1595",
    "raw_ref": "https://api.github.com/repos/ImageMagick/ImageMagick6/commits/19651f3db63fa1511ed83a348c4c82fa553f8d01",
    "html_ref": "https://github.com/ImageMagick/ImageMagick6/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01",
    "author": "Cristy",
    "changes_stats": {
        "total": 105,
        "additions": 59,
        "deletions": 46
    },
    "files": [
        {
            "sha": "9830eb7d305e6fcd80eb695bff9418490fde71c8",
            "filename": "coders/gif.c",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/ImageMagick/ImageMagick6/blob/19651f3db63fa1511ed83a348c4c82fa553f8d01/coders%2Fgif.c",
            "raw_url": "https://github.com/ImageMagick/ImageMagick6/raw/19651f3db63fa1511ed83a348c4c82fa553f8d01/coders%2Fgif.c",
            "contents_url": "https://api.github.com/repos/ImageMagick/ImageMagick6/contents/coders%2Fgif.c?ref=19651f3db63fa1511ed83a348c4c82fa553f8d01",
            "patch": "@@ -685,13 +685,15 @@ static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n       /*\n         Probe hash table.\n       */\n+      next_pixel=MagickFalse;\n+      displacement=1;\n       index=(IndexPacket) ((size_t) GetPixelIndex(indexes+x) & 0xff);\n       p++;\n       k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);\n       if (k >= MaxHashTable)\n         k-=MaxHashTable;\n-      next_pixel=MagickFalse;\n-      displacement=1;\n+      if (k < 0)\n+        continue;\n       if (hash_code[k] > 0)\n         {\n           if ((hash_prefix[k] == waiting_code) &&"
        },
        {
            "sha": "83dfcb24aeecc1651229b553c0ba3fed76f46180",
            "filename": "magick/fourier.c",
            "status": "modified",
            "additions": 55,
            "deletions": 44,
            "changes": 99,
            "blob_url": "https://github.com/ImageMagick/ImageMagick6/blob/19651f3db63fa1511ed83a348c4c82fa553f8d01/magick%2Ffourier.c",
            "raw_url": "https://github.com/ImageMagick/ImageMagick6/raw/19651f3db63fa1511ed83a348c4c82fa553f8d01/magick%2Ffourier.c",
            "contents_url": "https://api.github.com/repos/ImageMagick/ImageMagick6/contents/magick%2Ffourier.c?ref=19651f3db63fa1511ed83a348c4c82fa553f8d01",
            "patch": "@@ -226,9 +226,9 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n   progress=0;\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n   #pragma omp parallel for schedule(static) shared(progress,status) \\\n-    magick_number_threads(images,complex_images,images->rows,1L)\n+    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)\n #endif\n-  for (y=0; y < (ssize_t) images->rows; y++)\n+  for (y=0; y < (ssize_t) Cr_image->rows; y++)\n   {\n     register const PixelPacket\n       *magick_restrict Ai,\n@@ -245,14 +245,10 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n \n     if (status == MagickFalse)\n       continue;\n-    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,\n-      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);\n-    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,\n-      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);\n-    Br=GetCacheViewVirtualPixels(Br_view,0,y,\n-      MagickMax(Br_image->columns,Cr_image->columns),1,exception);\n-    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,\n-      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);\n+    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);\n+    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);\n+    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);\n+    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);\n     Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n     Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n     if ((Ar == (const PixelPacket *) NULL) ||\n@@ -264,7 +260,7 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n         status=MagickFalse;\n         continue;\n       }\n-    for (x=0; x < (ssize_t) images->columns; x++)\n+    for (x=0; x < (ssize_t) Cr_image->columns; x++)\n     {\n       switch (op)\n       {\n@@ -305,55 +301,70 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n             gamma;\n \n           gamma=PerceptibleReciprocal(Br->red*Br->red+Bi->red*Bi->red+snr);\n-          Cr->red=gamma*(Ar->red*Br->red+Ai->red*Bi->red);\n-          Ci->red=gamma*(Ai->red*Br->red-Ar->red*Bi->red);\n-          gamma=PerceptibleReciprocal(Br->green*Br->green+Bi->green*Bi->green+\n-            snr);\n-          Cr->green=gamma*(Ar->green*Br->green+Ai->green*Bi->green);\n-          Ci->green=gamma*(Ai->green*Br->green-Ar->green*Bi->green);\n-          gamma=PerceptibleReciprocal(Br->blue*Br->blue+Bi->blue*Bi->blue+snr);\n-          Cr->blue=gamma*(Ar->blue*Br->blue+Ai->blue*Bi->blue);\n-          Ci->blue=gamma*(Ai->blue*Br->blue-Ar->blue*Bi->blue);\n+          Cr->red=gamma*((double) Ar->red*Br->red+(double) Ai->red*Bi->red);\n+          Ci->red=gamma*((double) Ai->red*Br->red-(double) Ar->red*Bi->red);\n+          gamma=PerceptibleReciprocal((double) Br->green*Br->green+(double)\n+            Bi->green*Bi->green+snr);\n+          Cr->green=gamma*((double) Ar->green*Br->green+(double)\n+            Ai->green*Bi->green);\n+          Ci->green=gamma*((double) Ai->green*Br->green-(double)\n+            Ar->green*Bi->green);\n+          gamma=PerceptibleReciprocal((double) Br->blue*Br->blue+(double)\n+            Bi->blue*Bi->blue+snr);\n+          Cr->blue=gamma*((double) Ar->blue*Br->blue+(double)\n+            Ai->blue*Bi->blue);\n+          Ci->blue=gamma*((double) Ai->blue*Br->blue-(double)\n+             Ar->blue*Bi->blue);\n           if (images->matte != MagickFalse)\n             {\n-              gamma=PerceptibleReciprocal(Br->opacity*Br->opacity+Bi->opacity*\n-                Bi->opacity+snr);\n-              Cr->opacity=gamma*(Ar->opacity*Br->opacity+Ai->opacity*\n-                Bi->opacity);\n-              Ci->opacity=gamma*(Ai->opacity*Br->opacity-Ar->opacity*\n-                Bi->opacity);\n+              gamma=PerceptibleReciprocal((double) Br->opacity*Br->opacity+\n+                (double) Bi->opacity*Bi->opacity+snr);\n+              Cr->opacity=gamma*((double) Ar->opacity*Br->opacity+(double)\n+                Ai->opacity*Bi->opacity);\n+              Ci->opacity=gamma*((double) Ai->opacity*Br->opacity-(double)\n+                Ar->opacity*Bi->opacity);\n             }\n           break;\n         }\n         case MagnitudePhaseComplexOperator:\n         {\n-          Cr->red=sqrt(Ar->red*Ar->red+Ai->red*Ai->red);\n-          Ci->red=atan2(Ai->red,Ar->red)/(2.0*MagickPI)+0.5;\n-          Cr->green=sqrt(Ar->green*Ar->green+Ai->green*Ai->green);\n-          Ci->green=atan2(Ai->green,Ar->green)/(2.0*MagickPI)+0.5;\n-          Cr->blue=sqrt(Ar->blue*Ar->blue+Ai->blue*Ai->blue);\n+          Cr->red=sqrt((double) Ar->red*Ar->red+(double) Ai->red*Ai->red);\n+          Ci->red=atan2((double) Ai->red,(double) Ar->red)/(2.0*MagickPI)+0.5;\n+          Cr->green=sqrt((double) Ar->green*Ar->green+(double)\n+            Ai->green*Ai->green);\n+          Ci->green=atan2((double) Ai->green,(double) Ar->green)/\n+            (2.0*MagickPI)+0.5;\n+          Cr->blue=sqrt((double) Ar->blue*Ar->blue+(double) Ai->blue*Ai->blue);\n           Ci->blue=atan2(Ai->blue,Ar->blue)/(2.0*MagickPI)+0.5;\n           if (images->matte != MagickFalse)\n             {\n-              Cr->opacity=sqrt(Ar->opacity*Ar->opacity+Ai->opacity*Ai->opacity);\n-              Ci->opacity=atan2(Ai->opacity,Ar->opacity)/(2.0*MagickPI)+0.5;\n+              Cr->opacity=sqrt((double) Ar->opacity*Ar->opacity+(double)\n+                Ai->opacity*Ai->opacity);\n+              Ci->opacity=atan2((double) Ai->opacity,(double) Ar->opacity)/\n+                (2.0*MagickPI)+0.5;\n             }\n           break;\n         }\n         case MultiplyComplexOperator:\n         {\n-          Cr->red=QuantumScale*(Ar->red*Br->red-Ai->red*Bi->red);\n-          Ci->red=QuantumScale*(Ai->red*Br->red+Ar->red*Bi->red);\n-          Cr->green=QuantumScale*(Ar->green*Br->green-Ai->green*Bi->green);\n-          Ci->green=QuantumScale*(Ai->green*Br->green+Ar->green*Bi->green);\n-          Cr->blue=QuantumScale*(Ar->blue*Br->blue-Ai->blue*Bi->blue);\n-          Ci->blue=QuantumScale*(Ai->blue*Br->blue+Ar->blue*Bi->blue);\n+          Cr->red=QuantumScale*((double) Ar->red*Br->red-(double)\n+            Ai->red*Bi->red);\n+          Ci->red=QuantumScale*((double) Ai->red*Br->red+(double)\n+            Ar->red*Bi->red);\n+          Cr->green=QuantumScale*((double) Ar->green*Br->green-(double)\n+            Ai->green*Bi->green);\n+          Ci->green=QuantumScale*((double) Ai->green*Br->green+(double)\n+            Ar->green*Bi->green);\n+          Cr->blue=QuantumScale*((double) Ar->blue*Br->blue-(double)\n+            Ai->blue*Bi->blue);\n+          Ci->blue=QuantumScale*((double) Ai->blue*Br->blue+(double)\n+            Ar->blue*Bi->blue);\n           if (images->matte != MagickFalse)\n             {\n-              Cr->opacity=QuantumScale*(Ar->opacity*Br->opacity-Ai->opacity*\n-                Bi->opacity);\n-              Ci->opacity=QuantumScale*(Ai->opacity*Br->opacity+Ar->opacity*\n-                Bi->opacity);\n+              Cr->opacity=QuantumScale*((double) Ar->opacity*Br->opacity-\n+                (double) Ai->opacity*Bi->opacity);\n+              Ci->opacity=QuantumScale*((double) Ai->opacity*Br->opacity+\n+                (double) Ar->opacity*Bi->opacity);\n             }\n           break;\n         }\n@@ -380,7 +391,7 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n           Ci->green=Ai->green-Bi->green;\n           Cr->blue=Ar->blue-Br->blue;\n           Ci->blue=Ai->blue-Bi->blue;\n-          if (images->matte != MagickFalse)\n+          if (Cr_image->matte != MagickFalse)\n             {\n               Cr->opacity=Ar->opacity-Br->opacity;\n               Ci->opacity=Ai->opacity-Bi->opacity;"
        }
    ],
    "parent_commit_sha": "c6c454db784cd9c1500437c758d8456a2bba01f0"
}