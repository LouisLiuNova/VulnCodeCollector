{
    "owner": "torvalds",
    "repo": "linux",
    "commit_sha": "b92946e2919134ebe2a4083e4302236295ea2a73",
    "commit_massage": "macvtap: zerocopy: validate vectors before building skb\n\nThere're several reasons that the vectors need to be validated:\n\n- Return error when caller provides vectors whose num is greater than UIO_MAXIOV.\n- Linearize part of skb when userspace provides vectors grater than MAX_SKB_FRAGS.\n- Return error when userspace provides vectors whose total length may exceed\n- MAX_SKB_FRAGS * PAGE_SIZE.\n\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>",
    "raw_ref": "https://api.github.com/repos/torvalds/linux/commits/b92946e2919134ebe2a4083e4302236295ea2a73",
    "html_ref": "https://github.com/torvalds/linux/commit/b92946e2919134ebe2a4083e4302236295ea2a73",
    "author": "jasowang",
    "changes_stats": {
        "total": 25,
        "additions": 21,
        "deletions": 4
    },
    "files": [
        {
            "sha": "163559c16988329b57878b376d320a8ed8db5bfd",
            "filename": "drivers/net/macvtap.c",
            "status": "modified",
            "additions": 21,
            "deletions": 4,
            "changes": 25,
            "blob_url": "https://github.com/torvalds/linux/blob/b92946e2919134ebe2a4083e4302236295ea2a73/drivers%2Fnet%2Fmacvtap.c",
            "raw_url": "https://github.com/torvalds/linux/raw/b92946e2919134ebe2a4083e4302236295ea2a73/drivers%2Fnet%2Fmacvtap.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/drivers%2Fnet%2Fmacvtap.c?ref=b92946e2919134ebe2a4083e4302236295ea2a73",
            "patch": "@@ -529,9 +529,10 @@ static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n \t\t}\n \t\tbase = (unsigned long)from->iov_base + offset;\n \t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n+\t\tif (i + size > MAX_SKB_FRAGS)\n+\t\t\treturn -EMSGSIZE;\n \t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n-\t\tif ((num_pages != size) ||\n-\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n+\t\tif (num_pages != size) {\n \t\t\tfor (i = 0; i < num_pages; i++)\n \t\t\t\tput_page(page[i]);\n \t\t\treturn -EFAULT;\n@@ -651,7 +652,7 @@ static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n \tint err;\n \tstruct virtio_net_hdr vnet_hdr = { 0 };\n \tint vnet_hdr_len = 0;\n-\tint copylen;\n+\tint copylen = 0;\n \tbool zerocopy = false;\n \n \tif (q->flags & IFF_VNET_HDR) {\n@@ -680,15 +681,31 @@ static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n \tif (unlikely(len < ETH_HLEN))\n \t\tgoto err;\n \n+\terr = -EMSGSIZE;\n+\tif (unlikely(count > UIO_MAXIOV))\n+\t\tgoto err;\n+\n \tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n \t\tzerocopy = true;\n \n \tif (zerocopy) {\n+\t\t/* Userspace may produce vectors with count greater than\n+\t\t * MAX_SKB_FRAGS, so we need to linearize parts of the skb\n+\t\t * to let the rest of data to be fit in the frags.\n+\t\t */\n+\t\tif (count > MAX_SKB_FRAGS) {\n+\t\t\tcopylen = iov_length(iv, count - MAX_SKB_FRAGS);\n+\t\t\tif (copylen < vnet_hdr_len)\n+\t\t\t\tcopylen = 0;\n+\t\t\telse\n+\t\t\t\tcopylen -= vnet_hdr_len;\n+\t\t}\n \t\t/* There are 256 bytes to be copied in skb, so there is enough\n \t\t * room for skb expand head in case it is used.\n \t\t * The rest buffer is mapped from userspace.\n \t\t */\n-\t\tcopylen = vnet_hdr.hdr_len;\n+\t\tif (copylen < vnet_hdr.hdr_len)\n+\t\t\tcopylen = vnet_hdr.hdr_len;\n \t\tif (!copylen)\n \t\t\tcopylen = GOODCOPY_LEN;\n \t} else"
        }
    ],
    "parent_commit_sha": "01d6657b388438def19c8baaea28e742b6ed32ec"
}