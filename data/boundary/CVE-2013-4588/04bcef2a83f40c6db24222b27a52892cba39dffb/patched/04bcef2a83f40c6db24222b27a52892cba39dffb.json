{
    "owner": "torvalds",
    "repo": "linux",
    "commit_sha": "04bcef2a83f40c6db24222b27a52892cba39dffb",
    "commit_massage": "ipvs: Add boundary check on ioctl arguments\n\nThe ipvs code has a nifty system for doing the size of ioctl command\ncopies; it defines an array with values into which it indexes the cmd\nto find the right length.\n\nUnfortunately, the ipvs code forgot to check if the cmd was in the\nrange that the array provides, allowing for an index outside of the\narray, which then gives a \"garbage\" result into the length, which\nthen gets used for copying into a stack buffer.\n\nFix this by adding sanity checks on these as well as the copy size.\n\n[ horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX ]\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nAcked-by: Julian Anastasov <ja@ssi.bg>\nSigned-off-by: Simon Horman <horms@verge.net.au>\nSigned-off-by: Patrick McHardy <kaber@trash.net>",
    "raw_ref": "https://api.github.com/repos/torvalds/linux/commits/04bcef2a83f40c6db24222b27a52892cba39dffb",
    "html_ref": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb",
    "author": "fenrus75",
    "changes_stats": {
        "total": 14,
        "additions": 13,
        "deletions": 1
    },
    "files": [
        {
            "sha": "c37ac2d7bec44da042af844717084489aae511a6",
            "filename": "net/netfilter/ipvs/ip_vs_ctl.c",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/torvalds/linux/blob/04bcef2a83f40c6db24222b27a52892cba39dffb/net%2Fnetfilter%2Fipvs%2Fip_vs_ctl.c",
            "raw_url": "https://github.com/torvalds/linux/raw/04bcef2a83f40c6db24222b27a52892cba39dffb/net%2Fnetfilter%2Fipvs%2Fip_vs_ctl.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/net%2Fnetfilter%2Fipvs%2Fip_vs_ctl.c?ref=04bcef2a83f40c6db24222b27a52892cba39dffb",
            "patch": "@@ -2077,6 +2077,10 @@ do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n+\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n+\t\treturn -EINVAL;\n+\tif (len < 0 || len >  MAX_ARG_LEN)\n+\t\treturn -EINVAL;\n \tif (len != set_arglen[SET_CMDID(cmd)]) {\n \t\tpr_err(\"set_ctl: len %u != %u\\n\",\n \t\t       len, set_arglen[SET_CMDID(cmd)]);\n@@ -2352,17 +2356,25 @@ do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n {\n \tunsigned char arg[128];\n \tint ret = 0;\n+\tunsigned int copylen;\n \n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n+\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n+\t\treturn -EINVAL;\n+\n \tif (*len < get_arglen[GET_CMDID(cmd)]) {\n \t\tpr_err(\"get_ctl: len %u < %u\\n\",\n \t\t       *len, get_arglen[GET_CMDID(cmd)]);\n \t\treturn -EINVAL;\n \t}\n \n-\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n+\tcopylen = get_arglen[GET_CMDID(cmd)];\n+\tif (copylen > 128)\n+\t\treturn -EINVAL;\n+\n+\tif (copy_from_user(arg, user, copylen) != 0)\n \t\treturn -EFAULT;\n \n \tif (mutex_lock_interruptible(&__ip_vs_mutex))"
        }
    ],
    "parent_commit_sha": "ae24e578de02b87cce3dc59248c29b2ecb071e9e"
}