{
    "owner": "qemu",
    "repo": "qemu",
    "commit_sha": "e3737b820b45e54b059656dc3f914f895ac7a88b",
    "commit_massage": "bochs: Check catalog_size header field (CVE-2014-0143)\n\nIt should neither become negative nor allow unbounded memory\nallocations. This fixes aborts in g_malloc() and an s->catalog_bitmap\nbuffer overflow on big endian hosts.\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>",
    "raw_ref": "https://api.github.com/repos/qemu/qemu/commits/e3737b820b45e54b059656dc3f914f895ac7a88b",
    "html_ref": "https://github.com/qemu/qemu/commit/e3737b820b45e54b059656dc3f914f895ac7a88b",
    "author": "kevmw",
    "changes_stats": {
        "total": 36,
        "additions": 35,
        "deletions": 1
    },
    "files": [
        {
            "sha": "0ffa9c1ba77c37d9d48b8691ed7533d47f30dc7c",
            "filename": "block/bochs.c",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/qemu/qemu/blob/e3737b820b45e54b059656dc3f914f895ac7a88b/block%2Fbochs.c",
            "raw_url": "https://github.com/qemu/qemu/raw/e3737b820b45e54b059656dc3f914f895ac7a88b/block%2Fbochs.c",
            "contents_url": "https://api.github.com/repos/qemu/qemu/contents/block%2Fbochs.c?ref=e3737b820b45e54b059656dc3f914f895ac7a88b",
            "patch": "@@ -123,7 +123,14 @@ static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n+    /* Limit to 1M entries to avoid unbounded allocation. This is what is\n+     * needed for the largest image that bximage can create (~8 TB). */\n     s->catalog_size = le32_to_cpu(bochs.catalog);\n+    if (s->catalog_size > 0x100000) {\n+        error_setg(errp, \"Catalog size is too large\");\n+        return -EFBIG;\n+    }\n+\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n@@ -142,6 +149,12 @@ static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n+    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n+        error_setg(errp, \"Catalog size is too small for this disk size\");\n+        ret = -EINVAL;\n+        goto fail;\n+    }\n+\n     qemu_co_mutex_init(&s->lock);\n     return 0;\n "
        },
        {
            "sha": "902ef0f03693adede63de350a91274430ea83b85",
            "filename": "tests/qemu-iotests/078",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/qemu/qemu/blob/e3737b820b45e54b059656dc3f914f895ac7a88b/tests%2Fqemu-iotests%2F078",
            "raw_url": "https://github.com/qemu/qemu/raw/e3737b820b45e54b059656dc3f914f895ac7a88b/tests%2Fqemu-iotests%2F078",
            "contents_url": "https://api.github.com/repos/qemu/qemu/contents/tests%2Fqemu-iotests%2F078?ref=e3737b820b45e54b059656dc3f914f895ac7a88b",
            "patch": "@@ -43,6 +43,7 @@ _supported_proto generic\n _supported_os Linux\n \n catalog_size_offset=$((0x48))\n+disk_size_offset=$((0x58))\n \n echo\n echo \"== Read from a valid image ==\"\n@@ -55,6 +56,18 @@ _use_sample_img empty.bochs.bz2\n poke_file \"$TEST_IMG\" \"$catalog_size_offset\" \"\\xff\\xff\\xff\\xff\"\n { $QEMU_IO -c \"read 0 512\" $TEST_IMG; } 2>&1 | _filter_qemu_io | _filter_testdir\n \n+echo\n+echo \"== Overflow for catalog size * sizeof(uint32_t) ==\"\n+_use_sample_img empty.bochs.bz2\n+poke_file \"$TEST_IMG\" \"$catalog_size_offset\" \"\\x00\\x00\\x00\\x40\"\n+{ $QEMU_IO -c \"read 0 512\" $TEST_IMG; } 2>&1 | _filter_qemu_io | _filter_testdir\n+\n+echo\n+echo \"== Too small catalog bitmap for image size ==\"\n+_use_sample_img empty.bochs.bz2\n+poke_file \"$TEST_IMG\" \"$disk_size_offset\" \"\\x00\\xc0\\x0f\\x00\\x00\\x00\\x00\\x7f\"\n+{ $QEMU_IO -c \"read 2T 4k\" $TEST_IMG; } 2>&1 | _filter_qemu_io | _filter_testdir\n+\n # success, all done\n echo \"*** done\"\n rm -f $seq.full"
        },
        {
            "sha": "7254693b08bd823813545424d72096f228c97427",
            "filename": "tests/qemu-iotests/078.out",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/qemu/qemu/blob/e3737b820b45e54b059656dc3f914f895ac7a88b/tests%2Fqemu-iotests%2F078.out",
            "raw_url": "https://github.com/qemu/qemu/raw/e3737b820b45e54b059656dc3f914f895ac7a88b/tests%2Fqemu-iotests%2F078.out",
            "contents_url": "https://api.github.com/repos/qemu/qemu/contents/tests%2Fqemu-iotests%2F078.out?ref=e3737b820b45e54b059656dc3f914f895ac7a88b",
            "patch": "@@ -5,6 +5,14 @@ read 512/512 bytes at offset 0\n 512 bytes, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)\n \n == Negative catalog size ==\n-qemu-io: can't open device TEST_DIR/empty.bochs: Could not open 'TEST_DIR/empty.bochs': Interrupted system call\n+qemu-io: can't open device TEST_DIR/empty.bochs: Catalog size is too large\n+no file open, try 'help open'\n+\n+== Overflow for catalog size * sizeof(uint32_t) ==\n+qemu-io: can't open device TEST_DIR/empty.bochs: Catalog size is too large\n+no file open, try 'help open'\n+\n+== Too small catalog bitmap for image size ==\n+qemu-io: can't open device TEST_DIR/empty.bochs: Catalog size is too small for this disk size\n no file open, try 'help open'\n *** done"
        }
    ],
    "parent_commit_sha": "246f65838d19db6db55bfb41117c35645a2c4789"
}