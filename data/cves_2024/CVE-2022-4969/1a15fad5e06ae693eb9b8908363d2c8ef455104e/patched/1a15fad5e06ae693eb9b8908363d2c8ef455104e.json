{
    "owner": "bwoodsend",
    "repo": "rockhopper",
    "commit_sha": "1a15fad5e06ae693eb9b8908363d2c8ef455104e",
    "commit_massage": "Fix a potential security exploit in RaggedArray.loads(buffer, ldtype=np.uint64).\n\nWhen parsing binary data with ldtype=np.uint64, if a length is sufficiently\nclose to 2^64 that it causes the parsing buffer pointer (starting from &buffer)\nto overflow, then arbitrary memory owned by the current process and whose\naddress is < &buffer can be read. Should the overflow map the pointer to a\nlocation not owned by the current process, a segfault will occur.\n\nOverflow is now caught and raised as a ValueError() (like in any other case\nwhere the parsing fails).",
    "raw_ref": "https://api.github.com/repos/bwoodsend/rockhopper/commits/1a15fad5e06ae693eb9b8908363d2c8ef455104e",
    "html_ref": "https://github.com/bwoodsend/rockhopper/commit/1a15fad5e06ae693eb9b8908363d2c8ef455104e",
    "author": "bwoodsend",
    "changes_stats": {
        "total": 49,
        "additions": 47,
        "deletions": 2
    },
    "files": [
        {
            "sha": "801b0dc2d528875db1a2a53bf1507025ed435c96",
            "filename": "rockhopper/src/ragged_array.c",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/bwoodsend/rockhopper/blob/1a15fad5e06ae693eb9b8908363d2c8ef455104e/rockhopper%2Fsrc%2Fragged_array.c",
            "raw_url": "https://github.com/bwoodsend/rockhopper/raw/1a15fad5e06ae693eb9b8908363d2c8ef455104e/rockhopper%2Fsrc%2Fragged_array.c",
            "contents_url": "https://api.github.com/repos/bwoodsend/rockhopper/contents/rockhopper%2Fsrc%2Fragged_array.c?ref=1a15fad5e06ae693eb9b8908363d2c8ef455104e",
            "patch": "@@ -59,8 +59,9 @@ int count_rows(void * raw, int raw_length, int length_power, int big_endian,\n \n   int rows = 0;\n \n+  void * start = raw;\n   void * end = raw + raw_length;\n-  while (raw <= end - (1 << length_power)) {\n+  while (raw <= end - (1 << length_power) && raw >= start) {\n     uint64_t length = read(raw);\n     raw += (1 << length_power);\n     raw += length * itemsize;"
        },
        {
            "sha": "a1a55ef69e8c4163b70a399c09392289e5f1a521",
            "filename": "setup.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/bwoodsend/rockhopper/blob/1a15fad5e06ae693eb9b8908363d2c8ef455104e/setup.py",
            "raw_url": "https://github.com/bwoodsend/rockhopper/raw/1a15fad5e06ae693eb9b8908363d2c8ef455104e/setup.py",
            "contents_url": "https://api.github.com/repos/bwoodsend/rockhopper/contents/setup.py?ref=1a15fad5e06ae693eb9b8908363d2c8ef455104e",
            "patch": "@@ -34,7 +34,7 @@\n     extras_require={\n         \"test\": [\n             'pytest>=3', 'pytest-order', 'coverage', 'pytest-cov',\n-            'coverage-conditional-plugin'\n+            'coverage-conditional-plugin', 'hypothesis'\n         ]\n     },\n     license=\"MIT license\","
        },
        {
            "sha": "03f56bc85e1c9e2ce6019155859701a07fc50277",
            "filename": "tests/test_io.py",
            "status": "modified",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/bwoodsend/rockhopper/blob/1a15fad5e06ae693eb9b8908363d2c8ef455104e/tests%2Ftest_io.py",
            "raw_url": "https://github.com/bwoodsend/rockhopper/raw/1a15fad5e06ae693eb9b8908363d2c8ef455104e/tests%2Ftest_io.py",
            "contents_url": "https://api.github.com/repos/bwoodsend/rockhopper/contents/tests%2Ftest_io.py?ref=1a15fad5e06ae693eb9b8908363d2c8ef455104e",
            "patch": "@@ -7,6 +7,7 @@\n import numpy as np\n import pytest\n from cslug import ptr\n+from hypothesis import given, strategies, settings, Verbosity, example\n \n from rockhopper import RaggedArray\n from rockhopper._ragged_array import _2_power, _big_endian\n@@ -61,6 +62,49 @@ def test_dump_load(dtype, byteorder):\n     assert consumed == len(bin)\n \n \n+int_types = [\n+    np.uint8, np.uint16, np.uint32, np.uint64,\n+    np.int8, np.int16, np.int32, np.int64,\n+]\n+blob = bytes(range(256)) + bytes(range(256))[::-1]\n+\n+\n+@pytest.mark.parametrize(\"dtype\", int_types)\n+@pytest.mark.parametrize(\"ldtype\", int_types)\n+def test_loads_pointer_overflow_guard(dtype, ldtype):\n+    \"\"\"Test that the check for pointer overflowing caused by reading a huge row\n+    length works.\"\"\"\n+    for i in range(-30, len(blob)):\n+        try:\n+            RaggedArray.loads(blob[i: i+30], dtype=dtype, ldtype=ldtype)\n+        except ValueError:\n+            pass\n+\n+\n+@pytest.mark.parametrize(\"dtype\", int_types)\n+@pytest.mark.parametrize(\"ldtype\", int_types)\n+def test_fuzz_loads(dtype, ldtype):\n+    \"\"\"Scan for possible segfaults.\n+\n+    All invalid inputs must lead to a ValueError rather than a seg-fault or\n+    RaggedArray.loads() could be tricked into reading arbitrary memory addresses\n+    by a maliciously constructed invalid data file.\n+\n+    \"\"\"\n+    @given(strategies.binary())\n+    @example(b'\\xc0\\\\\\\\\\xb0\\x93\\x91\\xff\\xffpEfe\\x167\\xee')\n+    def fuzz(x):\n+        print(x)\n+        try:\n+            self, _ = RaggedArray.loads(x, dtype=dtype, ldtype=ldtype)\n+        except ValueError:\n+            pass\n+        else:\n+            assert self.dumps(ldtype=ldtype).tobytes() == x\n+\n+    fuzz()\n+\n+\n def test_dump_byteorder():\n     self = RaggedArray.from_nested([[0x0109, 0x0208, 0x0307]], dtype=np.uint16)\n "
        }
    ],
    "parent_commit_sha": "a971948ca5191e1c84335c646be5d5d554ca9a80"
}