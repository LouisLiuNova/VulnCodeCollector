{
    "owner": "torvalds",
    "repo": "linux",
    "commit_sha": "c0f5ecee4e741667b2493c742b60b6218d40b3aa",
    "commit_massage": "USB: cdc-wdm: fix buffer overflow\n\nThe buffer for responses must not overflow.\nIf this would happen, set a flag, drop the data and return\nan error after user space has read all remaining data.\n\nSigned-off-by: Oliver Neukum <oliver@neukum.org>\nCC: stable@kernel.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "raw_ref": "https://api.github.com/repos/torvalds/linux/commits/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
    "html_ref": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
    "author": "Oliver Neukum",
    "changes_stats": {
        "total": 23,
        "additions": 20,
        "deletions": 3
    },
    "files": [
        {
            "sha": "122d056d96d570c2d59762fda22e0e973ac081b5",
            "filename": "drivers/usb/class/cdc-wdm.c",
            "status": "modified",
            "additions": 20,
            "deletions": 3,
            "changes": 23,
            "blob_url": "https://github.com/torvalds/linux/blob/c0f5ecee4e741667b2493c742b60b6218d40b3aa/drivers%2Fusb%2Fclass%2Fcdc-wdm.c",
            "raw_url": "https://github.com/torvalds/linux/raw/c0f5ecee4e741667b2493c742b60b6218d40b3aa/drivers%2Fusb%2Fclass%2Fcdc-wdm.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/drivers%2Fusb%2Fclass%2Fcdc-wdm.c?ref=c0f5ecee4e741667b2493c742b60b6218d40b3aa",
            "patch": "@@ -56,6 +56,7 @@ MODULE_DEVICE_TABLE (usb, wdm_ids);\n #define WDM_RESPONDING\t\t7\n #define WDM_SUSPENDING\t\t8\n #define WDM_RESETTING\t\t9\n+#define WDM_OVERFLOW\t\t10\n \n #define WDM_MAX\t\t\t16\n \n@@ -155,6 +156,7 @@ static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n+\tint length = urb->actual_length;\n \n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n@@ -185,9 +187,17 @@ static void wdm_in_callback(struct urb *urb)\n \t}\n \n \tdesc->rerr = status;\n-\tdesc->reslength = urb->actual_length;\n-\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n-\tdesc->length += desc->reslength;\n+\tif (length + desc->length > desc->wMaxCommand) {\n+\t\t/* The buffer would overflow */\n+\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n+\t} else {\n+\t\t/* we may already be in overflow */\n+\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n+\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n+\t\t\tdesc->length += length;\n+\t\t\tdesc->reslength = length;\n+\t\t}\n+\t}\n skip_error:\n \twake_up(&desc->wait);\n \n@@ -435,6 +445,11 @@ static ssize_t wdm_read\n \t\t\trv = -ENODEV;\n \t\t\tgoto err;\n \t\t}\n+\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n+\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n+\t\t\trv = -ENOBUFS;\n+\t\t\tgoto err;\n+\t\t}\n \t\ti++;\n \t\tif (file->f_flags & O_NONBLOCK) {\n \t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n@@ -478,6 +493,7 @@ static ssize_t wdm_read\n \t\t\tspin_unlock_irq(&desc->iuspin);\n \t\t\tgoto retry;\n \t\t}\n+\n \t\tif (!desc->reslength) { /* zero length read */\n \t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n \t\t\tclear_bit(WDM_READ, &desc->flags);\n@@ -1004,6 +1020,7 @@ static int wdm_post_reset(struct usb_interface *intf)\n \tstruct wdm_device *desc = wdm_find_device(intf);\n \tint rv;\n \n+\tclear_bit(WDM_OVERFLOW, &desc->flags);\n \tclear_bit(WDM_RESETTING, &desc->flags);\n \trv = recover_from_urb_loss(desc);\n \tmutex_unlock(&desc->wlock);"
        }
    ],
    "parent_commit_sha": "a57e82a18779ab8a5e5a1f5841cef937cf578913"
}